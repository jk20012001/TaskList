#include <common>
#include <cc-global>
#include <packing>
#include <cc-local>



#include <cc-shadow-map-base>
#if CC_RECEIVE_SHADOW
	#include <cc-shadow>
  /*#include <builtin/uniforms/cc-shadow-map>
  #include <common/shadow/native-pcf>
  
  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
  {
    float pcf = cc_shadowWHPBInfo.z;
    vec4 pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);
    if (pcf > 2.9) {
      return CCGetSpotLightShadowFactorSoft4X(pos, worldPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy, cc_matLightView, cc_shadowNFLSInfo);
    } else if (pcf > 1.9) { 
      return CCGetSpotLightShadowFactorSoft2X(pos, worldPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy, cc_matLightView, cc_shadowNFLSInfo);
    }else if (pcf > 0.9) { 
      return CCGetSpotLightShadowFactorSoft(pos, worldPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy, cc_matLightView, cc_shadowNFLSInfo);
    }else { 
      return CCGetSpotLightShadowFactorHard(pos, worldPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy, cc_matLightView, cc_shadowNFLSInfo); 
    }
  }
  
  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
  {
    float realtimeShadow = 1.0;
    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
  
    float pcf = cc_shadowWHPBInfo.z;
    if (pcf > 2.9) {
      realtimeShadow =  NativePCFShadowFactorSoft4X(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    } else if (pcf > 1.9) {
      realtimeShadow =  NativePCFShadowFactorSoft2X(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    }else if (pcf > 0.9) {
      realtimeShadow = NativePCFShadowFactorSoft(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    }else { 
      realtimeShadow = NativePCFShadowFactorHard(pos, cc_shadowMap, cc_shadowWHPBInfo.xy); 
    }
    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
  }
  
  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)
  {
    vec4 csmPos = vec4(1.0);
    int level = CCGetCSMLevel(csmPos, worldPos);
    if (level < 0) { return 1.0; }
    float realtimeShadow = 1.0;
  
    float pcf = cc_shadowWHPBInfo.z;
    if (pcf > 2.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = NativePCFShadowFactorSoft4X(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    } else if (pcf > 1.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = NativePCFShadowFactorSoft2X(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    } else if (pcf > 0.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = NativePCFShadowFactorSoft(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    }else { 
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = NativePCFShadowFactorHard(pos, cc_shadowMap, cc_shadowWHPBInfo.xy);
    }
    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
  }
#endif
  */
#endif
