#include <common>
#include <cc-global>
#include <packing>
#include <cc-local>



#include <cc-shadow-map-base>
#if CC_RECEIVE_SHADOW
  #include <common/math/coordinates>
  #include <cc-shadow>
  //#include <builtin/uniforms/cc-shadow-map>
  //#include <common/shadow/shadow>
  //#include <common/shadow/native-pcf>
  /*
  float CCGetLinearDepth(vec3 worldPos) {
    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
    return GetLinearDepthFromViewSpace(viewStartPos.xyz, cc_matLightView, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);
  }
  
  //////////////////////////////////////////////////////////Directional Light Shadow
  float CCGetShadowFactorHard (vec4 shadowPosWithDepthBias) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    return NativePCFShadowFactorHard(shadowNDCPos, cc_chadowMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetShadowFactorSoft (vec4 shadowPosWithDepthBias) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    return NativePCFShadowFactorSoft(shadowNDCPos, cc_chadowMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_chadowMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_chadowMap, cc_shadowWHPBInfo.xy);
  }
  
  
  //////////////////////////////////////////////////////////Spot Light Shadow
  float CCGetSpotShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    if (cc_shadowNFLSInfo.z > EPSILON) {
      shadowNDCPos.z = CCGetLinearDepth(worldPos);
    } else {
      shadowNDCPos.z = clipPos.z;
    }
  
    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetSpotShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    if (cc_shadowNFLSInfo.z > EPSILON) {
      shadowNDCPos.z = CCGetLinearDepth(worldPos);
    } else {
      shadowNDCPos.z = clipPos.z;
    }
  
    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetSpotShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    if (cc_shadowNFLSInfo.z > EPSILON) {
      shadowNDCPos.z = CCGetLinearDepth(worldPos);
    } else {
      shadowNDCPos.z = clipPos.z;
    }
  
    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy);
  }
  
  float CCGetSpotShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {
    vec3 shadowNDCPos = GetShadowNDCPos(shadowPosWithDepthBias);
    if (cc_shadowNFLSInfo.z > EPSILON) {
      shadowNDCPos.z = CCGetLinearDepth(worldPos);
    } else {
      shadowNDCPos.z = clipPos.z;
    }
  
    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotLightingMap, cc_shadowWHPBInfo.xy);
  }


//////////////////////////////////////////////////////////Main Functions
  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
  {
    float pcf = cc_shadowWHPBInfo.z;
    vec4 pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);
    if (pcf > 2.9) {
      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);
    } else if (pcf > 1.9) { 
      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);
    }else if (pcf > 0.9) { 
      return CCGetSpotLightShadowFactorSoft(pos, worldPos);
    }else { 
      return CCGetSpotLightShadowFactorHard(pos, worldPos);
    }
  }
  
  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
  {
    float realtimeShadow = 1.0;
    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
  
    float pcf = cc_shadowWHPBInfo.z;
    if (pcf > 2.9) {
      realtimeShadow =  CCGetShadowFactorSoft5X(pos);
    } else if (pcf > 1.9) {
      realtimeShadow =  CCGetShadowFactorSoft3X(pos);
    }else if (pcf > 0.9) {
      realtimeShadow = CCGetShadowFactorSoft(pos);
    }else { 
      realtimeShadow = CCGetShadowFactorHard(pos); 
    }
    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
  }
  
  
  int CCGetCSMLevel(out vec4 csmPos, vec3 worldPos) {
    for (int i = 0; i < NUMCASCADES; i++) {
      vec4 shadowPos = cc_matShadowViewProj_levels[i] * vec4(worldPos.xyz, 1.0);
      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;
      if (clipPos.x < (0.0 + cc_csmInfo.y) || clipPos.x > (1.0 - cc_csmInfo.y) ||
          clipPos.y < (0.0 + cc_csmInfo.y) || clipPos.y > (1.0 - cc_csmInfo.y) ||
          clipPos.z < 0.0 || clipPos.z > 1.0) {
        continue;
      }
      csmPos = cc_matShadowViewProjAtlas_levels[i] * vec4(worldPos.xyz, 1.0);
      return i;
    }
    return -1;
  }

  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)
  {
    vec4 csmPos = vec4(1.0);
    int level = CCGetCSMLevel(csmPos, worldPos);
    if (level < 0) { return 1.0; }
    float realtimeShadow = 1.0;
  
    float pcf = cc_shadowWHPBInfo.z;
    if (pcf > 2.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = CCGetShadowFactorSoft4X(pos);
    } else if (pcf > 1.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = CCGetShadowFactorSoft2X(pos);
    } else if (pcf > 0.9) {
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = CCGetShadowFactorSoft(pos);
    }else { 
      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y);
      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x);
      realtimeShadow = CCGetShadowFactorHard(pos);
    }
    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
  }
#endif
  */
#endif
