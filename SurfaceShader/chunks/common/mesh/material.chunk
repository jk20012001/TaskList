bool GetMetallicAlbedoFromDiffuseSpecularMathematic(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float channelFaultTolerant /*= 0.2*/, float f0 /*= 0.04*/)
{
	// inaccuracy match first
	//GetMetallicAlbedoFromDiffuseSpecular(metallic, albedo, diffuse, specular);

	vec3 delta = diffuse*diffuse + specular*specular + 2.0 * diffuse*specular - f0 * 4.0 * diffuse;

	vec3 deltaSqrt = sqrt(max(vec3(0.0), delta));
	// solver
	vec3 m = (-diffuse - specular + 2.0 * f0 + deltaSqrt) / (2.0 * f0);

	float solverMetallic = dot(m, vec3(1.0)) * 0.3333333333333;
	vec3 solverAlbedo = diffuse + specular - f0 * (1.0 - solverMetallic);

	bool isValidSolver = dot(delta, delta) > 0.0
		&& abs(m.x - m.y) < channelFaultTolerant && abs(m.x - m.z) < channelFaultTolerant
		&& m.x <= 1.0 && m.y <= 1.0 && m.z <= 1.0;
	
	metallic = isValidSolver ? solverMetallic : metallic;
	albedo = isValidSolver ? solverAlbedo : albedo;
	return isValidSolver;
}